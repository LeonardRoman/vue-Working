@inherits System.Web.Mvc.WebViewPage
<!DOCTYPE html>
<html>
<head>

    <script src="~/Scripts/jquery-1.10.2.min.js"></script>
    <script src="~/Scripts/jquery.signalR-2.4.1.min.js"></script>
    <script src="~/Scripts/vue.js"></script>
    <script src="~/signalr/hubs"></script>
    <title>SignalR Simple Chat</title>
    <style type="text/css">
        {
            box-sizing: border-box;
        }

        .container {
            overflow: hidden;
            background-color: #99CCFF;
            border: unset solid #808080;
            padding: 5px;
            margin: 0px;
            height: 95vh;
        }

        /* Добавлено */
        .wrap {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
        }


        .scrollArea {
            position: relative;
            overflow: auto; /* Добавляем полосы прокрутки */
            height: 100%; /*Высота блока */
            padding: 5px; /* Поля вокруг текста */
            border: solid 5px black; /* Параметры рамки */
            flex-grow: 1;
        }

        .item {
            margin: 2px;
            padding: 2px; /* Поля вокруг текста */
            border: double 1px black; /* Параметры рамки */
            background-color: #66CCFF;
        }

        .p1 {
            margin: 2px;
            padding: 2px; /* Поля вокруг текста */
        }

        .nam {
            color: red;
            font-size: large;
            /* margin-block-end: 13px;*/
        }

        .dat {
            color: brown;
            font-size: medium;
            font-style: oblique;
            float: right;
            /* margin-block-end: 13px;*/
        }

        /*.item:hover {
            box-shadow: inset 0 0 0 3px #a3a593;
            cursor: pointer;
        }*/
        .status {
            float: right;
            z-index: 2147483647;
            background: white;
        }

        textarea {
            margin: 2px;
            width: 99%;
            border: transparent;
        }

        .hided {
            display: block;
        }

        .loader {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            /*background-image:url(/Content/icons/loading.gif);*/
            /*align-content: center;*/
            background: rgba(204, 51, 255, 0.5);
        }

        .loader-icon {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body style="padding:0px;margin:0px" class="container">
    <div class="wrap" id="chatForm">


        {{connection.hub.state}}---{{connected}}

        <div>{{connectionState}}</div>
        <input type="button" value="reload" v-on:click="fetchMessages()" />
        <input type="button" value="stop" v-on:click="stop()" />
        <div id="scroll" class="scrollArea">

            <div class="item" v-for="(item,num) in messages" :v-key="item"
                 v-bind:style="getStyle(item.SenderName,item.Status)"
                 v-on:click="setMessageReaded(item.Id,item.Status)">
                @*<div class="status" >{{item.Status}}</div>*@
                <img class="status" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NS40IDQ1LjQiPjxwYXRoIGZpbGw9IiNmOTY5MGUiIGQ9Ik00MS4zIDE4LjZIMjYuOFY0YzAtMi0xLjgtNC00LTQtMi40IDAtNC4yIDItNC4yIDR2MTQuNkg0Yy0yIDAtNCAxLjgtNCA0IDAgMS4yLjUgMi4zIDEuMiAzIC44LjggMS44IDEuMyAzIDEuM2gxNC40djE0LjNjMCAxIC40IDIgMS4yIDMgLjcuNiAxLjggMSAzIDEgMi4yIDAgNC0xLjcgNC00VjI3aDE0LjVjMi4zIDAgNC0yIDQtNC4zcy0xLjgtNC00LTR6Ii8+PC9zdmc+" width="12">
                <p class="p1">
                    {{num}})
                    <span class="nam">{{item.SenderName}}</span>
                    {{item.Status}}
                    <span class="dat"> {{item.CrDate}}</span>
                </p>
                <pre class="p1">{{item.Message}}</pre>


            </div>
        </div>
        <textarea v-model="message" oninput="auto_grow(this)"></textarea>
        <input type="button" v-on:click="sendMessage()" value="Send" :disabled="message.length==0" />
        <div v-for="(fileInf,num) in filesFrame" :v-key="fileInf">
            <div v-if='fileInf.fileName.length==0'>
                <input type="file" v-on:change="showFileSize()" />
            </div>
            <div v-if='fileInf.fileSize.length>0'>
                <span> {{num+1}}</span>
                <span>{{fileInf.fileName}}</span>
                <span>{{fileInf.fileSize}}</span>
                <button >
                    <img src="~/Content/icons/delete.jpg" height="20" alt="удалить файл"
                         style="vertical-align: middle">
                </button>
            </div>
        </div>
        <div class="loader" v-bind:style="{display:connected}">
            <img class="loader-icon" src="~/Content/icons/loading.gif" />
        </div>
    </div>

    <script type="text/javascript">
        function getBase64(file) {
            var reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = function () {
                for (var i = 0; i < reader.result.length; i++) {
                    chat.server.send(substr(i, 10000), reader.result);
                }
            };
            reader.onerror = function (error) {
                console.log('Error: ', error);
            };
        }

        function GetFormatedFileSize(elem) {
            console.log(elem);
            var fileInp = elem;//document.getElementById('file');
            var fileSizeStr = '';
            if (fileInp.files.length === 0) return fileSizeStr;
            var fileSize = fileInp.files[0].size;
            console.log(fileSize);
            if (fileSize < 1024)
                fileSizeStr = fileSize + 'байт';
            else {
                if (fileSize < 1024 * 1024 / 2) {//все меньше 500 кбайт
                    fileSizeStr = (fileSize / 1024).toFixed(2) + ' Кбайт';
                } else {
                    fileSizeStr = (fileSize / (1024 * 1024)).toFixed(2) + ' Мбайт';
                }
            }
            return fileSizeStr;
        }

        function uploadFile(chatId, messageId) {
            var elem = document.getElementById('file');

            var file = elem.files[0];

            var req = new XMLHttpRequest();
            var formData = new FormData();
            formData.append("file", file);
            formData.append("chatId", messageId);
            formData.append("message", message);
            req.open("POST", 'chartForm/uploadFile');
            req.send(formData);

        }

        $.connection.hub.disconnected(function () {
            console.log('We are currently experiencing difficulties with the connection.');
            setTimeout($.connection.hub.start(), 3000);
        });

        $.connection.hub.error(function (error) {
            console.log('SignalR error: ' + error);
        });
        //плавная прокурутка при добавлении сообщения
        function scrollSmoothToBottom(id) {
            var div = document.getElementById(id);
            $('#' + id).animate({
                scrollTop: div.scrollHeight
            }, 500);
        }

        //
        function auto_grow(element) {

            element.style.height = "5px";
            element.style.height = (element.scrollHeight) + "px";
            // var form = document.getElementById('chatForm');
            // form.style.height = "5px";
            // form.style.height = (form.scrollHeight) + "px";
        }
    </script>
    <script type="text/javascript">
        var chatId = 444;
        var chat = $.connection.chatHub;
        var vue = new Vue({
            el: "#chatForm",
            data: {
                connection: $.connection,
                connectionSt: $.connection.hub.state,
                connectionState: '', connectionSt: 0,
                errors: 'Ok',
                messages: [],
                message: '',
                filesFrame: [{ fileName: '', fileSize: '', elem: null }],
            },
            computed: {
                connected: function () {
                    if (this.connectionSt == 1) {
                        return 'none';
                    }
                    return 'block';
                }
            },

            methods: {
                checkConnection: function (collBack) {
                    if (this.connection.connectionState !== 4) {
                        $.connection.hub.start().done(function () { collBack(); });
                    } else {
                        collBack();
                    }
                },
                stop: function () {
                    $.connection.hub.stop();
                },
                uploadFile: function () {
                    var fileInp = document.getElementById('file');
                    if (fileInp.files.length === 0) return;
                    var file = fileInp.files[0];
                    window.postMessage("getData", '*');

                    // getBase64(file);
                    //var req = new XMLHttpRequest();
                    //var formData = new FormData();
                    //formData.append("chatId", chatId);
                    //formData.append("file", file);
                    //req.open("POST", 'ChartForm/uploadFile');
                    //req.send(formData);

                }
                ,
                showFileSize: function () {
                    if (!event) { event = window.event; }
                    var el = (event.target || event.srcElement);
                    var curFrame = this.filesFrame[this.filesFrame.length - 1];
                    curFrame.fileSize = GetFormatedFileSize(el);
                    curFrame.fileName = el.files[0].name;
                    curFrame.el = el;
                    this.filesFrame.push({ fileName: '', fileSize: '' });
                },
                getFileElementVisible: function (fileSize) {
                    if (fileSize.length > 0) {
                        return { 'display': 'none' };
                    } else {
                        return { 'display': 'inline-block' };
                    }
                },
                getDelButtonVisible: function (fileSize) {
                    if (fileSize.length > 0) {
                        return { 'display': 'inline-block' };
                    } else {
                        return { 'display': 'none' };
                    }
                },
                //читаем сообщения
                fetchMessages: function () {
                    var fetchRef = this.fetch;
                    $.connection.hub.start()
                        .done(function () {
                            console.log('Now connected, connection ID=' + $.connection.hub.id);
                            chat.server.getMessages()
                                .done(function (val) { fetchRef(val); });
                        })
                        .fail(function (e) {
                            console.error('Could not Connect!' + e);
                            this.errors = e;
                        });
                },
                fetch: function (val) {
                    this.messages = val;
                },
                getStyle: function (senderName, status) {
                    var id = '';
                    if ($.connection.hub.id) { id = $.connection.hub.id.substr(0, 5); }
                    var cursor = 'pointer';
                    if (id === senderName) {
                        cursor = 'auto';
                    }

                    if (status < 2) {
                        return { 'background-color': 'red', cursor: cursor };
                    } else {
                        return { 'background-color': 'grey' };
                    }
                },
                setMessageReaded: function (id, status) {

                    if (status < 2) {
                        this.checkConnection(function () {
                            chat.server.setMessageReaded(id);
                        });
                    }
                },
                sendMessage: function () {
                    var v = window.parent.innerHeight;
                    window.parent.postMessage(this.message, '*');
                    var messRef = this.message;
                    if (this.message.length > 0) {
                        this.checkConnection(function () {
                            chat.server.send(messRef);
                        });
                    }
                },
                broadcastMessage: function (message) {
                    this.messages.push(message);
                    scrollSmoothToBottom('scroll');
                },
                changeMessageStatus: function (messageId, status) {
                    for (var i = 0; i < this.messages.length; i++) {
                        var mess = this.messages[i];
                        if (mess.Id === messageId) {
                            mess.Status = status;
                            break;
                        }
                    }
                },
                error: function (error) {
                    console.log('SignalR error: ' + error);
                },
                stateChanged: function (state) {
                    console.log(state);
                    var arr = [];
                    for (var key in $.connection.connectionState) {
                        arr[$.connection.connectionState[key]] = key;
                    }
                    this.connectionSt = $.connection.hub.state;
                    this.connectionState = arr[$.connection.hub.state];
                },
                getName: function () {
                    return 'name';
                }
            },

            mounted: function () {
                var sch = this.stateChanged;
                $.connection.hub.stateChanged(function (vvv) {
                    console.log('stateChanged.');
                    sch(vvv);
                });
                chat.client.getName = this.getName;

                chat.client.broadcastMessage = this.broadcastMessage;
                chat.client.changeMessageStatus = this.changeMessageStatus;
                $.connection.hub.error = this.error;

                this.fetchMessages();//начитываю сообщения
            }
        });
    </script>
</body>
</html>